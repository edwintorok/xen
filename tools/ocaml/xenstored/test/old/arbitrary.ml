open QCheck

(* See https://github.com/gasche/random-generator/blob/51351c16b587a1c4216d158e847dcfa6db15f009/random_generator.mli#L275-L325
    for background on fueled generators for recursive data structures.
   The difference here is that we build an N-ary tree, not a binary tree as in the example.
   So we need to spread the fuel among elements of a list of random size.
*)

(** [spread fuel] creates an array of a random size, and spreads fuel among array elements.
  Each array slot uses up at least 1 fuel itself.
  For example the full list of possible arrays with [4] fuel is:
  {[ [[|3|]; [|0; 2|]; [|1; 1|]; [|2; 0|]; [|0; 0; 0; 0|]] ]}
*)
let spread = function
  | 0 ->
      Gen.return [||]
  | n when n < 0 ->
      invalid_arg "negative fuel"
  | n ->
      Gen.(
        1 -- n
        >>= fun per_element ->
        (* We got n fuel to divide up, such that most elements have [per_element] fuel.
           Round up the number of elements *)
        let m = (n + per_element - 1) / per_element in
        (* each element uses up at least one fuel, this has to be subtracted before propagation *)
        let a = Array.make m (per_element - 1) in
        (* handle remainder *)
        a.(0) <- n - (per_element * (m - 1)) - 1 ;
        assert (Array.fold_left ( + ) m a = n) ;
        (* ensure that remainder is in a random position *)
        Gen.shuffle_a a >|= fun () -> a)

(** [spread_l fuel sized_element] spreads [fuel] among list elements,
    where each list element is created using [sized_element].
    [sized_element] needs to create an element of exactly the requested size
     (which may be a recursive element, that calls [spread_l] in turn).
    Each list element consumes 1 fuel implicitly and sized_element is called with decreased fuel.
 *)
let spread_l fuel (sized_elem : 'a Gen.sized) =
  Gen.(
    spread fuel
    >>= fun a ->
    a |> Array.map sized_elem |> Gen.flatten_a |> Gen.map Array.to_list)

module Tree = struct
  (* For better shrinking put the (recursive) list first *)
  type 'a t = Nodes of ('a t * 'a) list

  (** [empty] the empty tree (of size 1) *)
  let empty = Nodes []

  (** [nodes subtree] tree constructor *)
  let nodes children = Nodes children

  (** [tree elem_gen] generates a random tree, with elements generated by [elem_gen] *)
  let tree elem =
    Gen.sized @@ Gen.fix
    @@ fun self fuel ->
    (* self is the generator for a subtree *)
    let node fuel = Gen.(pair (self fuel) elem) in
    (* using spread_l ensures that fuel decreases by at least 1, thus ensuring termination *)
    Gen.map nodes @@ spread_l fuel node

  (** [zero _] is a default implementation for [small] *)
  let zero _ = 0

  (** [small elem_size tree] returns the count of nodes in the tree and the sum of element sizes
      as determined by [elem_size] *)
  let rec small ?(elem_size = zero) (Nodes tree) =
    List.fold_left
      (fun acc (subtree, elem) ->
        acc + elem_size elem + small ~elem_size subtree)
      1 tree

  (** [shrink ?elem tree] returns a list of potentially smaller trees based on [tree].
   *)
  let shrink ?(elem = Shrink.nil) =
    (* Shrinking needs to generate smaller trees (as determined by [small]),
       QCheck will keep iterating until it finds a smaller tree that still reproduces the bug.
       It will then invoke the shrinker again on the smaller tree to attempt to shrink it further.
       Once the tree shape cannot be shrunk further individual node elements will be shrunk.
    *)
    let rec tree (Nodes t) =
      (* first try to shrink the subtree to a leaf,
         and if that doesn't work then recursively shrink the subtree
      *)
      Iter.append (Iter.return empty)
      @@ Iter.map nodes
      @@ Shrink.list ~shrink:(Shrink.pair tree elem) t
    in
    tree

  (** [make arb] creates a tree generator with elements generated by [arb].
      The tree has a shrinker and size defined.
   *)
  let make arb =
    let gen = tree @@ gen arb in
    QCheck.make
      ~small:(small ?elem_size:arb.small)
      ~shrink:(shrink ?elem:arb.shrink) gen

  (** [paths_of_tree ~join tree] return all paths through the tree,
      with path elements joined using [join] *)
  let paths_of_tree ~join t =
    let rec paths_of_subtree (paths, path) (Nodes nodes) =
      ListLabels.fold_left nodes ~init:paths ~f:(fun paths (tree, elem) ->
          let path = elem :: path in
          paths_of_subtree (join (List.rev path) :: paths, path) tree)
    in
    paths_of_subtree ([], []) t

  let paths join arb =
    make arb
    (* we need to retain the tree, so that the shrinking is done on the tree,
       and not on the paths *)
    |> map_keep_input (paths_of_tree ~join)
end

module Case = struct
  type ('a, 'b) t =
    { case_tag: string
    ; orig: 'a QCheck.arbitrary
    ; map: 'a -> 'b
    ; shrink: 'a -> 'b Iter.t
    ; print: 'a Print.t
    ; small: 'a -> int }

  (** [make arb f] defines a new variant case with constructor arguments
      generated by [arb] and constructor [f]. *)
  let make case_tag orig map =
    let shrink a =
      match orig.QCheck.shrink with
      | None ->
          Iter.empty
      | Some s ->
          Iter.map map @@ s a
    in
    let small a = match orig.QCheck.small with None -> 0 | Some s -> s a in
    let print a = match orig.QCheck.print with None -> "_" | Some p -> p a in
    {case_tag; orig; map; shrink; small; print}

  type 'a call =
    { tag: string
    ; shrink_lazy: 'a Iter.t Lazy.t
    ; small_lazy: int Lazy.t
    ; print: string Lazy.t }

  (** [call tag case args] used by the implementation of [rev] to build a shrinker/small of appropriate type *)
  let call t a =
    { tag= t.case_tag
    ; shrink_lazy= lazy (t.shrink a)
    ; small_lazy= lazy (t.small a)
    ; print= lazy (t.print a) }

  (** [to_sum case] converts all variant cases to the same type so they can be put into a list *)
  let to_sum t = Gen.map t.map @@ QCheck.gen t.orig
end

(** [sum ~print ~rev cases] defines an arbitrary for a sum type consisting of [cases]
  variant case generators. [print] converts the sum type to a string.
  [rev] matches on the sum type and should invoke [Case.call <variant-tag> <variant-case-def> <args>].

  E.g.
  {|
  type t = A of int | B of float

  let case_a = Case.make "A" int (fun i -> A i)

  let case_b = Case.make "B" float (fun f -> B f)

  let rev t =
    match t with A i -> Case.call case_a i | B g -> Case.call case_b g

  let x =
    sum
      ~print:(fun _ -> failwith "TODO")
      [Case.to_sum case_a; Case.to_sum case_b]
  |}
 *)
let sum ~rev lst =
  let shrink b = Lazy.force (rev b).Case.shrink_lazy in
  let small b = Lazy.force (rev b).Case.small_lazy in
  let collect b = (rev b).Case.tag in
  let print b = let r = rev b in r.Case.tag ^ " " ^ Lazy.force r.print in
  QCheck.make ~shrink ~small ~collect ~print (Gen.oneof lst)

(*
let mk_packet op to_string arb =
  Case.make arb (fun x -> Xenbus.Packet.create 0 0 op (to_string x))

let read_packet =
  mk_packet Xenbus.Xb.Op.Read Store.Path.to_string (list path_element)

let write_packet =
  mk_packet Xenbus.Xb.Op.Write
    (fun (x, y) -> Store.Path.to_string x ^ "\x00" ^ y)
    (pair (list path_element) binary)

let packet =
  sum ~print:Xenbus.Packet.to_string
    [Case.to_sum read_packet; Case.to_sum write_packet]
*)

(** [binary] is a generator of strings containing \x00 characters. *)
let binary =
  (* increase frequency of '\x00' to 10%, otherwise it'd be ~1/256 *)
  string_gen (Gen.frequency [(10, Gen.return '\x00'); (90, Gen.char)])
  |> set_print String.escaped

(** [path_chars] valid path characters according to Xenstore protocol. *)
let path_chars =
  List.init 256 Char.chr
  |> List.filter Store.Path.char_is_valid
  |> Array.of_list |> Gen.oneofa

(** [path_element] a valid path element *)
let path_element =
   string_gen_of_size Gen.small_int path_chars

type tree = string Tree.t

let paths = Tree.paths Store.Path.to_string path_element

let with_validate p =
  map_same_type
  @@ fun v ->
  (* reject it in a way known to QCheck: precondition failed,
     instead of testcase failed *)
  assume @@ p v ;
  v

(** [non_nul string_arb] rejects strings generated by [string_arb] that contain '\x00'. *)
let non_nul = with_validate @@ fun s -> not (String.contains s '\x00')

(** [plus arb] generates a list of 1 or more elements generated by [arb] *)
let plus arb = list_of_size Gen.(map succ small_int) arb

(** [star arb] generates a list of 0 or more elements generated by [arb] *)
let star arb = list_of_size Gen.small_int arb

let reserved =
  string_of_size Gen.(frequency [(90, Gen.return 0); (10, Gen.small_int)])

(** According to xenstore protocol this could go up to 65535, but an actual domid
    shouldn't go above this value *)
let domid_first_reserved = 0x7FF0

(** [new_domid] generates DomU domids *)
let new_domid = 1 -- domid_first_reserved

let permty =
  let open Perms in
  oneofl [READ; WRITE; RDWR; NONE]

let perms domid =
  map
    (fun (domid, other, acls) -> Perms.Node.create domid other acls)
    ~rev:(fun n ->
      (Perms.Node.get_owner n, Perms.Node.get_other n, Perms.Node.get_acl n))
  @@ triple domid permty (small_list (pair domid permty))
