ifdef V
	ifeq ("$(origin V)", "command line")
		BUILD_VERBOSE = $(V)
	endif
else
	V := 1
	BUILD_VERBOSE := 1
endif
ifndef BUILD_VERBOSE
	BUILD_VERBOSE := 0
endif
ifeq ($(BUILD_VERBOSE),1)
	E := @true
	Q :=
else
	E := @echo
	Q := @
endif

.NOTPARALLEL:

%.cmo: %.ml
	$(call quiet-command, $(OCAMLC) $(OCAMLFLAGS) -c -o $@ $<,MLC,$@)

%.cmi: %.mli
	$(call quiet-command, $(OCAMLC) $(OCAMLFLAGS) -c -o $@ $<,MLI,$@)

%.cmx %.o: %.ml
	$(call quiet-command, $(OCAMLOPT) $(OCAMLFLAGS) -c -o $@ $<,MLOPT,$@)

%.ml: %.mll
	$(call quiet-command, $(OCAMLLEX) -q -o $@ $<,MLLEX,$@)

%.ml: %.mly
	$(call quiet-command, $(OCAMLYACC) -q $<,MLYACC,$@)

%.o: %.c
	$(call quiet-command, $(CC) $(CFLAGS) -c -o $@ $<,CC,$@)

META: META.in
	sed 's/@VERSION@/$(VERSION)/g' < $< $o

OCAML_SOURCES ?= $(wildcard *.ml *.mli)

# The sorted list of source files will be needed when linking
# dependencies need to be potentially regenerated whenever source changes:
# new dependencies might've been introduced
.ocamldep.make: $(OCAML_SOURCES) $(GENERATED_FILES)
	$(Q)echo -n "DEPSORTED_OCAML_SOURCES=" >$@.new
	$(Q)$(OCAMLDEP) -sort $^ >>$@.new
	$(Q)$(OCAMLDEP) $^ >>$@.new
	$(Q)mv $@.new $@

ifndef IS_CLEAN_ONLY_GOAL
include .ocamldep.make
endif

MLI=$(filter %.mli,$(DEPSORTED_OCAML_SOURCES))
ML=$(filter %.ml,$(DEPSORTED_OCAML_SOURCES))
PREINTF=$(MLI:.mli=.cmi)
PREOBJS=$(ML:.ml=)
PRELIBS=$(ML:.ml=.cmo) $(ML:.ml=.cmx)
OBJS=$(PREOBJS)
INTF=$(PREINTF)
ALL_OCAML_OBJS = $(OBJS)
ALL_OCAML_OBJ_SOURCES=$(ML)

ifneq (,$(OCAML_LIBRARY))
$(OCAML_LIBRARY)_OBJS= $(OCAML_LIBRARY)
$(OCAML_LIBRARY)_C_OBJS ?= $(wildcard *.c:.c=)
LIBS=$(OCAML_LIBRARY).cma $(OCAML_LIBRARY).cmxa
endif
ifneq (,$(OCAML_NOC_LIBRARY))
$(OCAML_NOC_LIBRARY)_OBJS= $(OCAML_LIBRARY)
$(OCAML_NOC_LIBRARY)_C_OBJS ?= $(wildcard *.c:.c=)
LIBS=$(OCAML_NOC_LIBRARY).cma $(OCAML_NOC_LIBRARY).cmxa
endif

all: $(PREINTF) $(PRELIBS) $(INTF) $(LIBS) $(PROGRAMS)

bins: $(PROGRAMS)

libs: $(LIBS)

clean: $(CLEAN_HOOKS)
	$(Q)rm -f .*.d *.o *.so *.a *.cmo *.cmi *.cma *.cmx *.cmxa *.annot *.spot *.spit $(LIBS) $(PROGRAMS) $(GENERATED_FILES) .ocamldep.make META

distclean: clean

quiet-command = $(if $(V),$1,@printf " %-8s %s\n" "$2" "$3" && $1)

mk-caml-lib-native = $(call quiet-command, $(OCAMLOPT) -a -o $1 $2 $3,MLA,$1)
mk-caml-lib-bytecode = $(call quiet-command, $(OCAMLC) -a -o $1 $2 $3,MLA,$1)

mk-caml-stubs = $(call quiet-command, $(OCAMLMKLIB) -o `basename $1 .a` $2,MKLIB,$1)
mk-caml-lib-stubs = \
	$(call quiet-command, $(AR) rcs $1 $2 && $(OCAMLMKLIB) -o `basename $1 .a | sed -e 's/^lib//'` $2,MKLIB,$1)

# define a library target <name>.cmxa and <name>.cma
define OCAML_LIBRARY_template
 $(1).cmxa: lib$(1)_stubs.a $(foreach obj,$($(1)_OBJS),$(obj).cmx)
	$(call mk-caml-lib-native,$$@, -cclib -l$(1)_stubs $(foreach lib,$(LIBS_$(1)),-cclib $(lib)), $(foreach obj,$($(1)_OBJS),$(obj).cmx))
 $(1).cma: $(foreach obj,$($(1)_OBJS),$(obj).cmo)
	$(call mk-caml-lib-bytecode,$$@, -dllib dll$(1)_stubs.so -cclib -l$(1)_stubs, $$+)
 $(1)_stubs.a: $(foreach obj,$$($(1)_C_OBJS),$(obj).o)
	$(call mk-caml-stubs,$$@, $$+)
 lib$(1)_stubs.a: $(foreach obj,$($(1)_C_OBJS),$(obj).o)
	$(call mk-caml-lib-stubs,$$@, $$+)
endef

define OCAML_NOC_LIBRARY_template
 $(1).cmxa: $(foreach obj,$($(1)_OBJS),$(obj).cmx)
	$(call mk-caml-lib-native,$$@, , $(foreach obj,$($(1)_OBJS),$(obj).cmx))
 $(1).cma: $(foreach obj,$($(1)_OBJS),$(obj).cmo)
	$(call mk-caml-lib-bytecode,$$@, , $$+)
endef

define OCAML_PROGRAM_template
 $(1): $(foreach obj,$($(1)_OBJS),$(obj).cmx) $($(1)_EXTRA_DEPS)
	$(call quiet-command, $(OCAMLOPT) $(OCAMLFLAGS) -o $$@ $($(1)_LIBS) $$+,MLBIN,$$@)
 $(1).byte: $(foreach obj,$($(1)_OBJS),$(obj).cmo)
	$(call quiet-command, $(OCAMLC) $(OCAMLFLAGS) -o $$@ $($(1)_BYTE_LIBS) $$+,MLBIN,$$@)
endef

define C_PROGRAM_template
 $(1): $(foreach obj,$($(1)_OBJS),$(obj).o)
	$(call quiet-command, $(CC) $(LDFLAGS) -o $$@ $$+,BIN,$$@)
endef

$(foreach lib,$(OCAML_LIBRARY),$(eval $(call OCAML_LIBRARY_template,$(lib))))
$(foreach lib,$(OCAML_NOC_LIBRARY),$(eval $(call OCAML_NOC_LIBRARY_template,$(lib))))
$(foreach p,$(OCAML_PROGRAM),$(eval $(call OCAML_PROGRAM_template,$(p))))
$(foreach p,$(C_PROGRAM),$(eval $(call C_PROGRAM_template,$(p))))
